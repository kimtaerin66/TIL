## plugin 이란?

로더가 각 파일단위로 처리했다면, 플러그인은 번들된 결과물 하나를 처리한다.

번들된 자바스크립트를 난독화하거나, 특정 텍스트를 추출하는 용도로 사용된다.

## plugin 사용법 
플러그인을 이해하기위해서 간단한 플러그인 예제만들기

src폴더에 myplugin.js 파일을 생성한다.

plugin은 class로 만들고, 내부 코드는 기존라이브러리에서 가져옴 

```js
//myplugin.js 
class MyPlugin {
  apply(compiler) {
    compiler.hooks.done.tap("My Plugin", stats => {
      console.log("MyPlugin: done")
    })
  }
}

module.exports = MyPlugin
```

빌드를해보면 console.log가 딱 한번만 찍한다.

이전에 loader를 빌드했을땐, js 파일의 갯수만큼  console.log가 찍혔다만

플러그인은 번들된 파일하나를 기준으로 동작하기에 딱 한번만 찍힌다.


## 번들 결과에 배너를 추가하는 플러그인 만들기

```js
//myplugin.js 
class MyPlugin {
    apply(compiler) {
        // compiler.plugin() 함수로 후처리한다
        compiler.hooks.emit.tapAsync('MyPlugin', (compilation, callback) => {
            const asset = compilation.assets["main.js"];
            const originalSource = asset.source();
            const banner = [
                '/**',
                ' * 이것은 BannerPlugin이 처리한 결과입니다.',
                ' * Build Date: 2025-07-01',
                ' */'
            ].join('\n');

            const newSource = banner + '\n' + originalSource;
            // webpack 4.0부터는 반드시 source와 size 둘 다 재정의해야 한다!
            compilation.assets['main.js'] ={
                source: () => newSource,
                size: () => Buffer.byteLength(newSource, 'utf8')
            }
            callback();
        })
    }
}

module.exports = MyPlugin
```

build후 main.js를 열어보면 가장윗부분에

/**
 * 이것은 BannerPlugin이 처리한 결과입니다.
 * Build Date: 2025-07-01
 */

이 문구가 추가되어있다.


## 자주 사용하는 플러그인
1. BannerPlugin

위에서 커스텀 플러그인으로 만들었던것과 비슷하게, 빌드한 결과물에 빌드 정보나, 커밋 버전 등을 추가할 수 있다.

간단하게 텍스트만 적는다면

```js
//webpack.config.js
module.exports = {
  plugins: [
        new webpack.BannerPlugin({
            banner:'이것은 배너입니다.'
        })
    ],
};
```
build 후 main.js를 확인하면 

![image](https://github.com/user-attachments/assets/3bd4cac2-2220-4e70-92c5-6816aa4d8bc4)

기본 텍스트보다 적고싶은 정보가 많다면, 배너를 따로 분리한다.

```js
//webpack.config.js
const path =require('path');
const webpack = require('webpack');
const childProcess = require('child_process')

const banner = ()=>{
    const commit = childProcess.execSync("git rev-parse --short HEAD")
    const user = childProcess.execSync("git config user.name")
    const date = new Date().toLocaleString()

    return (
        `commitVersion: ${commit}` + `Build Date: ${date}\n` + `Author: ${user}`
    )
}


//필수옵션 mode entry output
module.exports = {
    mode : 'development',
    entry: {
        main : './src/app.js'
    },
    output: {
     path:path.resolve('./dist'),
     filename : '[name].js'
    },
    plugins: [
        new webpack.BannerPlugin(banner)
    ],
};

```

이렇게 작성하고 build하면 main.js에 commitVersion과 오늘날짜, 커밋한 사람의 이름이 main.js 상단에 들어간다.

2. DefinePlugin

DefinePlugin은 환경정보를 제공하기위한 플러그인이다.

어플리케이션 배포시, 개발환경과 운영환경이 서로 다른 api 주소를 호출하게되는데,

이런 환경 정보를 이 플러그인에서 유동적으로 설정할 수 있다.

```js
//webpack.config.js

const webpack = require("webpack")
export default {
  plugins: [new webpack.DefinePlugin({})],
}

```

```js
//app.js
console.log(process.env.NODE_ENV) // "development"
```

DefinePlugin에 아무것도 설정하지않았지만 console.log를 찍어보면

webpack 설정당시 mode에 적었던 development가 출력된다.

이런식으로도 사용가능

```js
//webpack.config.js
const path =require('path');
const webpack = require('webpack');

const isDev = process.env.NODE_ENV !== 'production';

module.exports ={
    mode : 'production', //node_env
    entry: {
      main :'./src/App.js'
    },
    output: {
        path : path.resolve('./build'),
        filename : '[name].js'
    },
    plugins: [
        new webpack.DefinePlugin({
            'process.env.REACT_APP_BACKEND_URL': JSON.stringify(
                isDev
                    ? 'http://localhost:8090/api/'
                    : 'https://dev.test.co.kr/api/'
            )
        }),
    ]
}
```

3. HtmlWebpackPlugin

   html을 후처리하는데 사용되는 써드파티 패키지이다.(설치필요)

  ```node
  npm install -D html-webpack-plugin
  ```

html의 타이틀부분에 개발용은 타이틀(개발용), 실제 운영용은 타이틀만 보이게 해보자.







