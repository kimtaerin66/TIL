# 연관관계 설정

목표 : user 테이블과 order_detail 테이블에대해서 1:n 관계설정하기.

![image](https://user-images.githubusercontent.com/85108615/196834090-8671ab1b-6ed0-4a43-9378-2f6e22331601.png)

### order_detail.java

user테이블을 확인하면, order_detail에 대한 정보가 전혀없다.

반대로 order_detail을 확인하면 userId가 존재.

즉, order_detail의 입장에서 order_detail는 n이고 user는 1

그러므로 @ManyToOne 사용하기.

![image](https://user-images.githubusercontent.com/85108615/196834480-b0f7e2df-dcf1-45d8-94c8-f85b389d72a2.png)


또한 Long타입을 User타입으로 바꾸고, userId가 아닌 user라고 바꿔준다.

어노테이션을 통해 연관관계를 설정할때는 "반드시 객체의 이름"을 적어줘야한다.

```java
//order_detail
package com.example.study.model.entity;


import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import java.time.LocalDateTime;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity //자바는 카멜케이스, db는 스네이크케이스
public class OrderDetail {

    @Id
    @GeneratedValue()
    private  Long id;

    private LocalDateTime orderAt;

    //N : 1
    @ManyToOne
    private User user;

    private Long itemId;
}

```

### user.java

다시 user로 돌아와 order_detail에서 찾아올 user를 만들어줘야한다.


user의 입장에서 자신은 1, order_detail는 n = @OneToMany이고, list로 받아올수있다.

```java
    // 1 : n
    @OneToMany(fetch = FetchType.LAZY, mappedBy = "user")
    private List<OrderDetail> orderDetailList;
```

추가로 fetch를 lazy로 걸어주고,(추후설명)

mapping타입을 user로 작성 (이 user는 order_detail의 변수와 동일해야한다.)




