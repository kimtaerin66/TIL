## 분할정복 알고리즘이란?
주어진 문제를 더이상 나눌 수 없을때까지 나누어, 분할된 작은 문제들을 각각 해결한 후, 

이 해들을 결합해 원래 문제의 해를 구한다.

## 특징 

1. 분할된 작은 문제는 원래 문제와 동일 (입력크기만 작아짐)
ex) 피자 한판을 한조각으로 나눠도 피자는 동일하다. 

2. 분할된 작은 문제는 서로 독립적이다.

## 분할정복 방법의 처리 단계

1. 분할 
  : 주어진 문제를 여러개의 작은 문제로 분할한다.
2. 정복
   : 작은 문제를 더 이상 작게 나눌수 없다면, 해를 구한다.
3. 결합
   : 작은 문제의 헤를 통합하여, 원래 문제의 해를 구한다.

  마지막 3단계 결합단계는 필수가 아니다.

## 분할 정복을 사용하는 알고리즘

1. 이진 탐색 (분할크기가 동일)
2. 합병 정렬  (분할크기가 동일)
3. 퀵 정렬  (분할크기가 다름)
4. 선택 문제  (분할크기가 다름)
----------------------------------------------------------

## 이진탐색
정렬된 상태(오름차순)의 데이터가 있을때 사용하는 탐색법

### 탐색 방법 

1. 배열의 가운데 원소와 찾고자하는 값을 비교한다.
2. 두값이 같으면, 종료 / 아니라면 또한번 이진탐색(순환호출)

가운데 원소가 탐색 값보다 작다면, 오른쪽 배열 탐색
가운데 원소가 탐색 값보다 크다면, 왼쪽 배열 탐색

3. 값을 찾을때까지 반복


### 이진탐색에서 분할 및 비교횟수

입력크기가 n 일때 최대 분할 횟수는?

더이상 분할할 수 없는 상태 = 데이터가 1인상태까지 분할해야한다
=  log n

최대 비교횟수 = 최대 분할 횟수 + 1

T(n) = 비교 횟수의 합
    = 반복문 바깥수준에서의 비교횟수 + 순환 호출에서의 비교횟수

T(n) = T(n/2) + O(1)  = 데이터의 반 탐색 + 상수값

### 특징

1. 입력 배열의 데이터가 정렬된 경우만 가능
2. 삽입/삭제 연산은 나머지 데이터 이동이 필수 -> 그러므로 삽입삭제가 빈번한경우에서는 사용이 부적합하다.

-------------------------------------------------

## 퀵 정렬
특정한 원소를 기준으로 2개로 분할하고, 나눈 왼쪽먼저 퀵정렬 수행. 왼쪽 정렬이 끝났다면 오른쪽도 동일하게 반복한다.

피벗 = 주어진 배열을 두부분으로 나눌때, 기준이 되는 원소

보통 배열의 첫번째 원소 (A[0])를 피벗으로 지정한다.

### 탐색 방법

1.피벗을 기준으로 두 부분배열로 분할한다.
2. 두 부분배열에 대해서 퀵 정렬을 순환적으로 적용하여 정렬한다.

### 분할함수 

퀵 정렬에서 가장 중요한것은 분할함수 = 어떻게 가운데 피벗을 찾을것인가 이다.

분할함수 예제 

A[ ] = { 35 26 15 77 10 61 11 59 17 48 19 40 }

A[0]= 35를 피벗으로 두고 진행한다.

왼쪽에서는 피벗보다 큰값을 찾고, 오른쪽에서는 피벗보다 작은 값을 찾는다.

▶ 35 26 15 77 10 61 11 59 17 48 19 40   (77 ↔ 19)

▶ 35 26 15 19 10 61 11 59 17 48 77 40   (61 ↔ 17)

▶ 35 26 15 19 10 17 11 59 61 48 77 40   (35 ↔ 11)


###  최악의 시간 복잡도
퀵정렬에서 최악의 시간 복잡도가 되는경우

=> 피벗만 제자리를 잡고 나머지 모든 원소가 하나의 부분배열이 되는 경우
